"""
Command Executor Service for ChatOps CLI

Provides secure command execution with validation, sandboxing, output capturing,
and comprehensive error handling for DevOps commands generated by plugins.
"""

import asyncio
import logging
import os
import shlex
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum

from .langchain_integration import DevOpsCommand, CommandType, RiskLevel
from .os_detection import os_detection


class ExecutionStatus(Enum):
    """Status of command execution"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    TIMEOUT = "timeout"


@dataclass
class ExecutionResult:
    """Result of command execution"""
    command: str
    status: ExecutionStatus
    return_code: int
    stdout: str
    stderr: str
    execution_time: float
    start_time: datetime
    end_time: datetime
    error_message: Optional[str] = None
    user_cancelled: bool = False


@dataclass
class ExecutionContext:
    """Context for command execution"""
    working_directory: Path
    environment_vars: Dict[str, str]
    timeout_seconds: int = 30
    max_output_size: int = 1024 * 1024  # 1MB
    dry_run: bool = False
    interactive: bool = True
    log_execution: bool = True


class CommandValidator:
    """Validates commands before execution for security"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__ + ".CommandValidator")
        
        # Dangerous commands that should be blocked or require extra confirmation
        self._dangerous_patterns = [
            r'rm\s+-rf\s+/',          # rm -rf /
            r'sudo\s+rm\s+-rf',       # sudo rm -rf
            r'dd\s+.*of=/dev/',       # dd to block devices
            r'mkfs\.',                # filesystem formatting
            r'fdisk',                 # disk partitioning
            r'format\s+[a-zA-Z]:',    # Windows format command
            r'del\s+/s\s+/q\s+\*',    # Windows recursive delete
            r'rmdir\s+/s\s+/q',       # Windows recursive directory removal
        ]
        
        # Commands that require confirmation regardless of risk level
        self._confirmation_required = [
            'rm', 'rmdir', 'del', 'format', 'fdisk', 'mkfs',
            'docker rmi', 'docker rm', 'kubectl delete',
            'systemctl stop', 'systemctl disable', 'service stop'
        ]
        
        # Allowed commands that bypass certain restrictions
        self._safe_commands = [
            'ls', 'dir', 'cat', 'type', 'head', 'tail', 'grep', 'find',
            'ps', 'top', 'htop', 'df', 'du', 'free', 'uptime', 'whoami',
            'pwd', 'cd', 'echo', 'date', 'hostname', 'uname',
            'docker ps', 'docker images', 'docker logs', 'docker inspect',
            'kubectl get', 'kubectl describe', 'kubectl logs'
        ]

    def validate_command(self, command: str, dev_ops_command: DevOpsCommand) -> Tuple[bool, str]:
        """
        Validate command for security and safety.
        
        Args:
            command: Raw command string to validate
            dev_ops_command: DevOpsCommand object with metadata
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            # Check for dangerous patterns
            import re
            for pattern in self._dangerous_patterns:
                if re.search(pattern, command, re.IGNORECASE):
                    return False, f"Command contains dangerous pattern: {pattern}"
            
            # Check command length (prevent command injection)
            if len(command) > 1000:
                return False, "Command too long (max 1000 characters)"
            
            # Parse command safely
            try:
                parsed_cmd = shlex.split(command)
                if not parsed_cmd:
                    return False, "Empty command"
            except ValueError as e:
                return False, f"Invalid command syntax: {e}"
            
            # Check if base command is in safe list for low-risk operations
            base_cmd = parsed_cmd[0].lower()
            if dev_ops_command.risk_level == RiskLevel.SAFE:
                safe_prefixes = [cmd.split()[0] for cmd in self._safe_commands]
                if base_cmd not in safe_prefixes:
                    self.logger.warning(f"Safe command {base_cmd} not in whitelist")
            
            # Additional validation based on OS
            os_info = os_detection.get_os_info()
            if os_info.is_windows:
                # Windows-specific validations
                if 'format' in command.lower() and 'c:' in command.lower():
                    return False, "Attempted format of system drive"
            else:
                # Unix-specific validations
                if '>' in command and '/dev/' in command:
                    return False, "Potential device file manipulation"
            
            return True, ""
            
        except Exception as e:
            self.logger.error(f"Command validation error: {e}")
            return False, f"Validation error: {e}"

    def requires_confirmation(self, command: str, dev_ops_command: DevOpsCommand) -> bool:
        """Check if command requires user confirmation"""
        # High/critical risk always requires confirmation
        if dev_ops_command.risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]:
            return True
            
        # Explicitly marked for confirmation
        if dev_ops_command.requires_confirmation:
            return True
            
        # Check against confirmation patterns
        cmd_lower = command.lower()
        for pattern in self._confirmation_required:
            if pattern in cmd_lower:
                return True
                
        return False


class CommandExecutor:
    """
    Secure command executor with validation, sandboxing, and logging.
    
    Handles execution of DevOps commands generated by plugins with comprehensive
    security measures, output handling, and audit logging.
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        self.logger = logging.getLogger(__name__)
        self.validator = CommandValidator()
        
        # Configuration
        self.config = config or {}
        self.max_concurrent_executions = self.config.get('max_concurrent', 5)
        self.default_timeout = self.config.get('default_timeout', 30)
        self.log_directory = Path(self.config.get('log_directory', './.chatops_logs'))
        
        # Execution tracking
        self._running_commands: Dict[str, subprocess.Popen] = {}
        self._execution_history: List[ExecutionResult] = []
        self._execution_lock = asyncio.Lock()
        
        # Create log directory
        self.log_directory.mkdir(exist_ok=True)
        
        # Setup command history file
        self.history_file = self.log_directory / 'command_history.log'
        
    async def execute_command(
        self,
        dev_ops_command: DevOpsCommand,
        context: ExecutionContext,
        user_confirmation_callback = None
    ) -> ExecutionResult:
        """
        Execute a DevOps command with full security and logging.
        
        Args:
            dev_ops_command: DevOpsCommand object with command details
            context: ExecutionContext with execution parameters
            user_confirmation_callback: Function to get user confirmation
            
        Returns:
            ExecutionResult with command output and metadata
        """
        start_time = datetime.now()
        command_id = f"cmd_{int(time.time())}_{len(self._execution_history)}"
        
        self.logger.info(f"Executing command [{command_id}]: {dev_ops_command.command}")
        
        try:
            # Step 1: Command Validation
            is_valid, validation_error = self.validator.validate_command(
                dev_ops_command.command, dev_ops_command
            )
            
            if not is_valid:
                return ExecutionResult(
                    command=dev_ops_command.command,
                    status=ExecutionStatus.FAILED,
                    return_code=-1,
                    stdout="",
                    stderr=f"Validation failed: {validation_error}",
                    execution_time=0.0,
                    start_time=start_time,
                    end_time=datetime.now(),
                    error_message=validation_error
                )
            
            # Step 2: User Confirmation (if required)
            if self.validator.requires_confirmation(dev_ops_command.command, dev_ops_command):
                if user_confirmation_callback:
                    confirmed = await user_confirmation_callback(dev_ops_command)
                    if not confirmed:
                        return ExecutionResult(
                            command=dev_ops_command.command,
                            status=ExecutionStatus.CANCELLED,
                            return_code=0,
                            stdout="",
                            stderr="User cancelled execution",
                            execution_time=0.0,
                            start_time=start_time,
                            end_time=datetime.now(),
                            user_cancelled=True
                        )
                elif context.interactive:
                    # Default behavior: require confirmation for risky commands
                    return ExecutionResult(
                        command=dev_ops_command.command,
                        status=ExecutionStatus.CANCELLED,
                        return_code=0,
                        stdout="",
                        stderr="Command requires confirmation but no callback provided",
                        execution_time=0.0,
                        start_time=start_time,
                        end_time=datetime.now(),
                        user_cancelled=True
                    )
            
            # Step 3: Dry Run Check
            if context.dry_run:
                return ExecutionResult(
                    command=dev_ops_command.command,
                    status=ExecutionStatus.COMPLETED,
                    return_code=0,
                    stdout=f"[DRY RUN] Would execute: {dev_ops_command.command}",
                    stderr="",
                    execution_time=0.0,
                    start_time=start_time,
                    end_time=datetime.now()
                )
            
            # Step 4: Actual Execution
            result = await self._execute_subprocess(
                dev_ops_command.command,
                context,
                command_id
            )
            
            # Step 5: Log Execution
            if context.log_execution:
                await self._log_execution(dev_ops_command, result, context)
            
            return result
            
        except Exception as e:
            self.logger.error(f"Command execution error [{command_id}]: {e}")
            end_time = datetime.now()
            
            return ExecutionResult(
                command=dev_ops_command.command,
                status=ExecutionStatus.FAILED,
                return_code=-1,
                stdout="",
                stderr=f"Execution error: {str(e)}",
                execution_time=(end_time - start_time).total_seconds(),
                start_time=start_time,
                end_time=end_time,
                error_message=str(e)
            )

    async def _execute_subprocess(
        self,
        command: str,
        context: ExecutionContext,
        command_id: str
    ) -> ExecutionResult:
        """Execute command using subprocess with proper handling"""
        start_time = datetime.now()
        
        try:
            # Prepare environment
            env = os.environ.copy()
            env.update(context.environment_vars)
            
            # Determine shell based on OS
            os_info = os_detection.get_os_info()
            if os_info.is_windows:
                shell_cmd = ["powershell.exe", "-Command", command]
            else:
                shell_cmd = ["/bin/bash", "-c", command]
            
            async with self._execution_lock:
                # Check concurrent execution limit
                if len(self._running_commands) >= self.max_concurrent_executions:
                    raise RuntimeError("Maximum concurrent executions reached")
                
                # Start process
                process = await asyncio.create_subprocess_exec(
                    *shell_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    cwd=str(context.working_directory),
                    env=env
                )
                
                self._running_commands[command_id] = process
            
            try:
                # Wait for completion with timeout
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=context.timeout_seconds
                )
                
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()
                
                # Decode output
                stdout_str = stdout.decode('utf-8', errors='replace')
                stderr_str = stderr.decode('utf-8', errors='replace')
                
                # Truncate large outputs
                if len(stdout_str) > context.max_output_size:
                    stdout_str = stdout_str[:context.max_output_size] + "\n[OUTPUT TRUNCATED]"
                if len(stderr_str) > context.max_output_size:
                    stderr_str = stderr_str[:context.max_output_size] + "\n[ERROR OUTPUT TRUNCATED]"
                
                status = ExecutionStatus.COMPLETED if process.returncode == 0 else ExecutionStatus.FAILED
                
                return ExecutionResult(
                    command=command,
                    status=status,
                    return_code=process.returncode,
                    stdout=stdout_str,
                    stderr=stderr_str,
                    execution_time=execution_time,
                    start_time=start_time,
                    end_time=end_time
                )
                
            except asyncio.TimeoutError:
                # Kill process on timeout
                try:
                    process.kill()
                    await process.wait()
                except:
                    pass
                
                return ExecutionResult(
                    command=command,
                    status=ExecutionStatus.TIMEOUT,
                    return_code=-1,
                    stdout="",
                    stderr=f"Command timed out after {context.timeout_seconds} seconds",
                    execution_time=context.timeout_seconds,
                    start_time=start_time,
                    end_time=datetime.now(),
                    error_message="Execution timeout"
                )
                
            finally:
                # Clean up
                if command_id in self._running_commands:
                    del self._running_commands[command_id]
                    
        except Exception as e:
            end_time = datetime.now()
            execution_time = (end_time - start_time).total_seconds()
            
            return ExecutionResult(
                command=command,
                status=ExecutionStatus.FAILED,
                return_code=-1,
                stdout="",
                stderr=f"Subprocess execution failed: {str(e)}",
                execution_time=execution_time,
                start_time=start_time,
                end_time=end_time,
                error_message=str(e)
            )

    async def _log_execution(
        self,
        dev_ops_command: DevOpsCommand,
        result: ExecutionResult,
        context: ExecutionContext
    ):
        """Log command execution to history file"""
        try:
            log_entry = {
                'timestamp': result.start_time.isoformat(),
                'command': dev_ops_command.command,
                'description': dev_ops_command.description,
                'risk_level': dev_ops_command.risk_level.value,
                'command_type': dev_ops_command.command_type.value,
                'status': result.status.value,
                'return_code': result.return_code,
                'execution_time': result.execution_time,
                'working_directory': str(context.working_directory),
                'dry_run': context.dry_run,
                'user_cancelled': result.user_cancelled,
                'error_message': result.error_message
            }
            
            # Add to memory history
            self._execution_history.append(result)
            
            # Limit memory history size
            if len(self._execution_history) > 1000:
                self._execution_history = self._execution_history[-500:]
            
            # Write to log file
            import json
            with open(self.history_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(log_entry) + '\n')
                
        except Exception as e:
            self.logger.error(f"Failed to log execution: {e}")

    def get_execution_history(self, limit: int = 50) -> List[ExecutionResult]:
        """Get recent execution history"""
        return self._execution_history[-limit:]

    def get_running_commands(self) -> List[str]:
        """Get list of currently running commands"""
        return list(self._running_commands.keys())

    async def cancel_command(self, command_id: str) -> bool:
        """Cancel a running command"""
        if command_id in self._running_commands:
            try:
                process = self._running_commands[command_id]
                process.kill()
                await process.wait()
                return True
            except Exception as e:
                self.logger.error(f"Failed to cancel command {command_id}: {e}")
                return False
        return False

    async def cleanup(self):
        """Cleanup resources and stop all running commands"""
        for command_id in list(self._running_commands.keys()):
            await self.cancel_command(command_id)
        
        self.logger.info("CommandExecutor cleanup completed") 